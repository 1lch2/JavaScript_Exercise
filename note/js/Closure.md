# JavaScript基础 - 闭包
## 定义
闭包指的是那些引用了另一个函数作用域中变量的函数，通常在嵌套函数中实现。通常把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。

```js
function hi() {
    let name = "Someone";

    function greeting() {
        return name + ", hi";
    }
    return greeting();
}
```

一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。

一个函数可以访问在它的调用上下文中定义的变量，这个就是词法作用域（Lexical scope）。

## 作用
1. 保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰（操作自己的私有变量和外界没有关系）
2. 保存：如果当前上下文不被释放【只要上下文中的某个东西被外部占用即可】，则存储的这些私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了

## 形成条件
1. 函数的嵌套
2. 内部函数引用外部函数的局部变量，延长外部函数的变量生命周期

## 用途
1. 模仿块级作用域
2. 保护外部函数的变量 能够访问函数定义时所在的词法作用域(阻止其被回收)
3. 封装私有化变量
4. 创建模块

## 缺点
会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

## 函数执行过程
当一个函数被调用时，会执行以下步骤
1. JavaScript创建一个新的执行上下文，我们叫作本地执行上下文。
2. 这个本地执行上下文将有它自己的一组变量，这些变量将是这个执行上下文的本地变量。
3. 新的执行上下文被推到到执行堆栈中。可以将执行堆栈看作是一种保存程序在其执行中的位置的容器。

当一个函数结束时，会发生以下情况：
1. 这个本地执行上下文从执行堆栈中弹出。

2. 函数将返回值返回调用上下文。

    调用上下文是调用这个本地的执行上下文，它可以是全局执行上下文，也可以是另外一个本地的执行上下文。
    
    这取决于调用执行上下文来处理此时的返回值，返回的值可以是一个对象、一个数组、一个函数、一个布尔值等等，如果函数没有return语句，则返回undefined。

3. 这个本地执行上下文被销毁。
    
    销毁是很重要，这个本地执行上下文中声明的所有变量都将被删除，不在有变量，这个就是为什么 称为本地执行上下文中自有的变量。

## 工作机制
无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。

闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量。

见下例
```js
// 1. 在全局执行上下文中创建新变量 createCounter，并指定函数定义
function createCounter() {
  // 3. 调用函数并创建行的本地执行上下文

  // 4. 声明本地变量并赋值
  let counter = 0;

  // 5. 在本地执行上下文中声明名为 myFunction 的新变量
  // 变量内容为另一个函数定义
  // 此时创建了一个闭包并将其作为函数定义的一部分
  // 闭包包含作用域中的变量，这里是 counter
  const myFunction = function() {
    // 8. increment 变量定义的函数开始执行

    // 9. 寻找变量counter，在查找本地和全局上下文前先查找闭包
    // 在闭包中找到了变量，+1 后再次存储在闭包中
    counter = counter + 1;

    // 10. 返回值，销毁本地执行上下文
    return counter;
  }

  // 6. 返回 myFunction 变量的内容并删除本地执行上下文
  // 之后 myFunction 和 counter 不再存在
  // 控制权移交调用上下文，返回函数定义和它的闭包
  // 闭包中包含创建它时它所在作用域内的变量
  return myFunction;
}

// 2. 声明名为increment的新变量
// 现在它包含函数定义和闭包
const increment = createCounter();

// 7. 调用函数并赋值
// 创建新的执行上下文并开始执行函数
const c1 = increment();

// 11. 闭包中的 counter 值递增并返回
const c2 = increment();
const c3 = increment();
console.log('example increment', c1, c2, c3);

// 1, 2, 3
```

## 作用域查找
```js
let a = 1
function foo() {
  let a = 2
  function too() {
    console.log(a)
  }
  return too
}
foo()() // 2
```
`foo()()` 调用时依次执行了 foo、too 函数。too 虽然是在全局作用域里执行的，但是too定义在 foo 作用域里面，根据作用域链规则取最近的嵌套作用域的属性 a = 2。