# JavaScript基础 - 垃圾回收

## 标记清理

1. 变量进入上下文，也可理解为作用域，会加上标记，证明其存在于该上下文；
2. 将所有在上下文中的变量以及上下文中被访问引用的变量标记去掉，表明这些变量活跃有用；
3. 在此之后再被加上标记的变量标记为准备删除的变量，因为上下文中的变量已经无法访问它们；
4. 执行内存清理，销毁带标记的所有非活跃值并回收之前被占用的内存；

### 局限
- 由于是从根对象(全局对象)开始查找，对于那些无法从根对象查询到的对象都将被清除
- 回收后会形成内存碎片，影响后面申请大的连续内存空间

## 引用计数
引用计数策略相对而言不常用，因为弊端较多。

其思路是对每个值记录它被引用的次数，通过最后对次数的判断(引用数为0)来决定是否保留，具体的规则有

1. 声明一个变量，赋予它一个引用值时，计数+1；
2. 同一个值被赋予另外一个变量时，引用+1；
3. 保存对该值引用的变量被其他值覆盖，引用-1；
4. 引用为0，回收内存；

### 局限
循环引用导致永远无法被回收

## 内存泄露

意外声明全局变量
```js
function hello （）{
  name = 'tom'
}
hello();
```
未声明的对象会被绑定在全局对象上，就算不被使用了，也不会被回收，所以写代码的时候，一定要记得声明变量。

定时器
```js
let name = 'Tom';
setInterval(() => {
  console.log(name);
}, 100);
```
定时器的回调通过闭包引用了外部变量，如果定时器不清除，name会一直占用着内存，所以用定时器的时候最好明白自己需要哪些变量，检查定时器内部的变量，另外如果不用定时器了，记得及时清除定时器。

闭包
```js
let out = function() {
  let name = 'Tom';
  return function() {
    console.log(name);
  }
}
```
由于闭包会常驻内存，在这个例子中，如果out一直存在，name就一直不会被清理，如果name值很大的时候，就会造成比较严重的内存泄漏。所以一定要慎重使用闭包。

事件监听
```js
mounted() {
  window.addEventListener("resize",  () => {
    //do something
  });
}
```
在页面初始化时绑定了事件监听，但是在页面离开的时候未清除事监听，就会导致内存泄漏。